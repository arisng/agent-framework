@page "/"
@using System.ComponentModel
@using System.Net.Http.Headers
@using System.Text
@using System.Text.Json
@using AGUIDojoClient.Models
@inject IAGUIChatClientFactory ClientFactory
@inject IApprovalHandler ApprovalHandler
@inject IJsonPatchApplier JsonPatchApplier
@inject IStateManager StateManager
@inject NavigationManager Nav
@implements IDisposable

<PageTitle>AG-UI Dojo Chat</PageTitle>

<ChatHeader OnNewChat="@ResetConversationAsync"
            AvailableEndpoints="@ClientFactory.AvailableEndpoints"
            SelectedEndpointPath="@selectedEndpointPath"
            OnEndpointChanged="@OnEndpointChangedAsync" />

<ChatMessageList Messages="@messages" InProgressMessage="@currentResponseMessage">
    <NoMessagesContent>
        <div>Ask the assistant a question to start a conversation.</div>
    </NoMessagesContent>
</ChatMessageList>
<div class="chat-container">
    <ChatSuggestions OnSelected="@AddUserMessageAsync" @ref="@chatSuggestions" />
    <ChatInput OnSend="@AddUserMessageAsync" @ref="@chatInput" />
</div>

@* Show approval dialog when there's a pending approval *@
@if (currentPendingApproval is not null)
{
    <ApprovalDialog Approval="@currentPendingApproval"
                    OnApproved="@OnApprovalApproved"
                    OnRejected="@OnApprovalRejected" />
}

@* Show Plan Progress component when we have an active plan (Agentic Generative UI) *@
@if (currentPlan is not null)
{
    <div class="plan-progress-container">
        <PlanProgress Plan="@currentPlan" />
    </div>
}

@* Show Recipe Editor when using the Shared State endpoint *@
@if (IsSharedStateEndpoint)
{
    <div class="shared-state-container">
        <RecipeEditor Recipe="@StateManager.CurrentRecipe" RecipeChanged="@OnRecipeChanged" />
    </div>
}

@* Show Document Preview when using the Predictive State Updates endpoint *@
@if (IsPredictiveStateEndpoint && currentDocumentState is not null)
{
    <div class="predictive-state-container">
        <DocumentPreview DocumentState="@currentDocumentState" IsPreview="@isDocumentPreview" Title="Document Preview" />
    </div>
}

@code {
    private const string SystemPrompt = @"
        You are a helpful assistant.
        ";

    private const string DefaultEndpointPath = "agentic_chat";
    private const int ThrottleDelayMs = 100; // Throttle StateHasChanged to prevent render thrashing

    private int statefulMessageCount;
    private readonly ChatOptions chatOptions = new();
    private readonly List<ChatMessage> messages = new();
    private CancellationTokenSource? currentResponseCancellation;
    private ChatMessage? currentResponseMessage;
    private ChatInput? chatInput;
    private ChatSuggestions? chatSuggestions;
    private string selectedEndpointPath = DefaultEndpointPath;
    private IChatClient? activeChatClient;
    private PendingApproval? currentPendingApproval;
    private TaskCompletionSource<bool>? approvalTaskSource;
    private Plan? currentPlan;
    private DocumentState? currentDocumentState;
    private bool isDocumentPreview = true;
    private DateTime lastStateChangeTime = DateTime.MinValue;
    private readonly HashSet<string> seenFunctionCallIds = new();
    private readonly HashSet<string> seenFunctionResultCallIds = new();
    private bool pendingStateChange = false;
    private System.Timers.Timer? throttleTimer;

    /// <summary>
    /// Gets whether the currently selected endpoint is the Shared State endpoint.
    /// </summary>
    private bool IsSharedStateEndpoint => selectedEndpointPath.Equals("shared_state", StringComparison.OrdinalIgnoreCase);

    /// <summary>
    /// Gets whether the currently selected endpoint is the Predictive State Updates endpoint.
    /// </summary>
    private bool IsPredictiveStateEndpoint => selectedEndpointPath.Equals("predictive_state_updates", StringComparison.OrdinalIgnoreCase);

    /// <summary>
    /// Gets whether the currently selected endpoint is the Agentic Generative UI endpoint.
    /// This endpoint requires special handling for STATE_DELTA events.
    /// </summary>
    private bool IsAgenticGenerativeUiEndpoint => selectedEndpointPath.Equals("agentic_generative_ui", StringComparison.OrdinalIgnoreCase);

    protected override void OnInitialized()
    {
        statefulMessageCount = 0;
        messages.Add(new(ChatRole.System, SystemPrompt));
        activeChatClient = ClientFactory.CreateClient(selectedEndpointPath);
        
        // Initialize state manager for Shared State feature
        if (IsSharedStateEndpoint)
        {
            StateManager.Initialize();
        }

        // Initialize throttle timer for debounced UI updates
        throttleTimer = new System.Timers.Timer(ThrottleDelayMs);
        throttleTimer.AutoReset = false;
        throttleTimer.Elapsed += OnThrottleElapsed;
    }

    /// <summary>
    /// Throttled StateHasChanged to prevent render thrashing during rapid streaming updates.
    /// </summary>
    private void ThrottledStateHasChanged()
    {
        DateTime now = DateTime.UtcNow;
        if ((now - lastStateChangeTime).TotalMilliseconds >= ThrottleDelayMs)
        {
            lastStateChangeTime = now;
            InvokeAsync(StateHasChanged);
        }
        else
        {
            // Schedule a deferred update
            pendingStateChange = true;
            throttleTimer?.Stop();
            throttleTimer?.Start();
        }
    }

    private void OnThrottleElapsed(object? sender, System.Timers.ElapsedEventArgs e)
    {
        if (pendingStateChange)
        {
            pendingStateChange = false;
            lastStateChangeTime = DateTime.UtcNow;
            InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// Handles endpoint selection change by creating a new client and resetting the conversation.
    /// </summary>
    private async Task OnEndpointChangedAsync(string newEndpointPath)
    {
        if (string.Equals(selectedEndpointPath, newEndpointPath, StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        selectedEndpointPath = newEndpointPath;
        activeChatClient = ClientFactory.CreateClient(selectedEndpointPath);
        await ResetConversationAsync();
        
        // Initialize or clear state manager based on new endpoint
        if (IsSharedStateEndpoint)
        {
            StateManager.Initialize();
        }
        else
        {
            StateManager.Clear();
        }
    }

    private async Task AddUserMessageAsync(ChatMessage userMessage)
    {
        CancelAnyCurrentResponse();

        // For shared state endpoint, add state DataContent to the user message
        // AGUIChatClient extracts DataContent from the last message and sends it as state
        if (IsSharedStateEndpoint && StateManager.HasActiveState)
        {
            DataContent stateContent = StateManager.CreateStateContent();
            userMessage.Contents.Add(stateContent);
        }

        // Add the user message to the conversation
        messages.Add(userMessage);
        chatSuggestions?.Clear();
        await chatInput!.FocusAsync();

        await ProcessAgentResponseAsync();
    }

    /// <summary>
    /// Processes the agent response, handling approval requests if they occur.
    /// For the Agentic Generative UI endpoint, also starts a parallel stream to capture STATE_DELTA events.
    /// </summary>
    private async Task ProcessAgentResponseAsync()
    {
        bool hasApprovalResponses;

        do
        {
            hasApprovalResponses = false;
            List<FunctionResultContent> approvalResponses = [];

            // Stream and display a new response from the IChatClient
            var responseText = new TextContent("");
            currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);
            StateHasChanged();
            currentResponseCancellation = new();

            try
            {
                await foreach (var update in activeChatClient!.GetStreamingResponseAsync(messages.Skip(statefulMessageCount), chatOptions, currentResponseCancellation.Token))
                {
                    // Check for approval requests and Plan state updates in the update
                    foreach (var content in update.Contents)
                    {
                        if (content is FunctionCallContent fcc && ApprovalHandler.TryExtractApprovalRequest(fcc, out var approval) && approval is not null)
                        {
                            // Show approval dialog and wait for user decision
                            currentPendingApproval = approval;
                            approvalTaskSource = new TaskCompletionSource<bool>();
                            StateHasChanged();

                            bool approved = await approvalTaskSource.Task;

                            // Create approval response
                            var response = ApprovalHandler.CreateApprovalResponse(approval.ApprovalId, approved);
                            approvalResponses.Add(response);

                            // Also add rejection response to currentResponseMessage for immediate display
                            // This ensures the rejection message is rendered with appropriate styling
                            if (!approved && currentResponseMessage is not null)
                            {
                                currentResponseMessage.Contents.Add(response);
                            }

                            currentPendingApproval = null;
                            approvalTaskSource = null;
                            StateHasChanged();
                        }
                        // Handle Plan state snapshots (Agentic Generative UI)
                        else if (content is DataContent dc && IsPlanStateSnapshot(dc))
                        {
                            Plan? plan = TryParsePlanSnapshot(dc);
                            if (plan is not null)
                            {
                                currentPlan = plan;
                                StateHasChanged();
                            }
                        }
                        // Handle Plan state deltas (JSON Patch for step updates)
                        else if (content is DataContent patchDc && IsPlanStateDelta(patchDc))
                        {
                            if (currentPlan is not null)
                            {
                                List<JsonPatchOperation>? operations = TryParsePatchOperations(patchDc);
                                if (operations is not null)
                                {
                                    JsonPatchApplier.ApplyPatch(currentPlan, operations);
                                    StateHasChanged();
                                }
                            }
                        }
                        // Handle Recipe state snapshots (Shared State feature)
                        else if (content is DataContent recipeDc && IsSharedStateEndpoint && StateManager.TryExtractRecipeSnapshot(recipeDc, out Recipe? recipe) && recipe is not null)
                        {
                            StateManager.UpdateFromServerSnapshot(recipe);
                            StateHasChanged();
                        }
                        // Handle Document state snapshots (Predictive State Updates feature)
                        else if (content is DataContent docDc && IsPredictiveStateEndpoint && TryExtractDocumentSnapshot(docDc, out DocumentState? docState) && docState is not null)
                        {
                            currentDocumentState = docState;
                            isDocumentPreview = true; // Still streaming
                            ThrottledStateHasChanged();
                        }
                    }

                    // Consolidate content: only add non-duplicate FunctionCallContent and skip redundant DataContent
                    // This prevents excessive DOM elements from streaming updates
                    foreach (AIContent content in update.Contents)
                    {
                        if (content is TextContent)
                        {
                            continue; // Text is handled separately via responseText accumulation
                        }
                        
                        if (content is FunctionCallContent fcc)
                        {
                            // Only add FunctionCallContent once per CallId to avoid duplicates
                            if (fcc.CallId is not null && !seenFunctionCallIds.Contains(fcc.CallId))
                            {
                                seenFunctionCallIds.Add(fcc.CallId);
                                currentResponseMessage?.Contents.Add(content);
                            }
                        }
                        else if (content is DataContent dc)
                        {
                            // For DataContent, consolidate by replacing previous instance of same category
                            // This prevents accumulating ~200 state snapshots in the message
                            ConsolidateDataContent(currentResponseMessage!, dc);
                        }
                        else if (content is FunctionResultContent frc)
                        {
                            // Only add FunctionResultContent once per CallId to avoid duplicates
                            // Duplicates occur because SSE streaming may emit the same result multiple times
                            // as the response progresses, and conversation history reconstruction may re-send results
                            if (frc.CallId is not null && !seenFunctionResultCallIds.Contains(frc.CallId))
                            {
                                seenFunctionResultCallIds.Add(frc.CallId);
                                currentResponseMessage?.Contents.Add(content);
                            }
                            else if (frc.CallId is null)
                            {
                                // No CallId means we can't dedupe - add it directly
                                currentResponseMessage?.Contents.Add(content);
                            }
                        }
                        else
                        {
                            // Other content types (ErrorContent) - add directly
                            currentResponseMessage?.Contents.Add(content);
                        }
                    }
                    
                    responseText.Text += update.Text;
                    chatOptions.ConversationId = update.ConversationId;
                    ThrottledStateHasChanged();
                }
            }
            catch (OperationCanceledException)
            {
                // User cancelled the operation
            }
            catch (HttpRequestException ex)
            {
                // Handle HTTP errors (e.g., from rejected approvals that cause server errors)
                responseText.Text = $"Error: {ex.Message}";
                ChatMessageItem.NotifyChanged(currentResponseMessage);
            }

            catch (Exception ex)
            {
                // Handle unexpected errors gracefully
                responseText.Text = $"An unexpected error occurred: {ex.Message}";
                ChatMessageItem.NotifyChanged(currentResponseMessage);
            }
            // Store the final response in the conversation
            messages.Add(currentResponseMessage!);
            currentResponseMessage = null;

            // If there were approval responses, add them as a tool message and continue
            // IMPORTANT: Do NOT update statefulMessageCount here - we need to send the full 
            // message history including the request_approval FunctionCallContent so the server's
            // ProcessIncomingFunctionApprovals can match it with the approval response.
            if (approvalResponses.Count > 0)
            {
                // Check if any responses were rejections
                bool hasAnyRejection = approvalResponses.Any(r => IsRejectionResponse(r));

                foreach (var response in approvalResponses)
                {
                    messages.Add(new ChatMessage(ChatRole.Tool, [response]));
                }

                // If rejection occurred, don't continue the approval loop.
                // Continuing after rejection can cause HTTP 400 errors because the
                // conversation history becomes malformed when sent to the LLM provider.
                // (Error: "An assistant message with 'tool_calls' must be followed by 
                // tool messages responding to each 'tool_call_id'")
                // The user can send a new message to try again with a fresh conversation.
                if (hasAnyRejection)
                {
                    hasApprovalResponses = false;
                    // Reset conversation state so the next user message starts fresh
                    chatOptions.ConversationId = null;
                    statefulMessageCount = messages.Count;
                }
                else
                {
                    hasApprovalResponses = true;
                }
            }
            else
            {
                // Only update statefulMessageCount when there are no pending approval workflows
                statefulMessageCount = chatOptions.ConversationId is not null ? messages.Count : 0;
            }

            // Mark document as finalized when streaming completes (for Predictive State Updates)
            if (IsPredictiveStateEndpoint && currentDocumentState is not null)
            {
                isDocumentPreview = false;
                StateHasChanged();
            }

        } while (hasApprovalResponses);

        chatSuggestions?.Update(messages);
    }

    /// <summary>
    /// Handles approval action from the dialog.
    /// </summary>
    private void OnApprovalApproved(string approvalId)
    {
        approvalTaskSource?.TrySetResult(true);
    }

    /// <summary>
    /// Handles rejection action from the dialog.
    /// </summary>
    private void OnApprovalRejected(string approvalId)
    {
        approvalTaskSource?.TrySetResult(false);
    }

    /// <summary>
    /// Handles recipe changes from the RecipeEditor component.
    /// Updates the state manager with the new recipe data.
    /// </summary>
    private void OnRecipeChanged(Recipe recipe)
    {
        StateManager.UpdateRecipe(recipe);
    }

    private void CancelAnyCurrentResponse()
    {
        // If a response was cancelled while streaming, include it in the conversation so it's not lost
        if (currentResponseMessage is not null)
        {
            messages.Add(currentResponseMessage);
        }

        currentResponseCancellation?.Cancel();
        currentResponseMessage = null;
        currentPendingApproval = null;
        approvalTaskSource?.TrySetCanceled();
        approvalTaskSource = null;
        ApprovalHandler.ClearPendingApprovals();
    }

    private async Task ResetConversationAsync()
    {
        CancelAnyCurrentResponse();
        messages.Clear();
        messages.Add(new(ChatRole.System, SystemPrompt));
        chatOptions.ConversationId = null;
        statefulMessageCount = 0;
        currentPlan = null;
        currentDocumentState = null;
        isDocumentPreview = true;
        seenFunctionCallIds.Clear();
        seenFunctionResultCallIds.Clear();
        ApprovalHandler.ClearPendingApprovals();
        chatSuggestions?.Clear();
        
        // Reinitialize state manager for Shared State endpoint
        if (IsSharedStateEndpoint)
        {
            StateManager.Initialize();
        }
        else
        {
            StateManager.Clear();
        }
        
        await chatInput!.FocusAsync();
    }

    /// <summary>
    /// Determines if DataContent represents a Plan state snapshot (Agentic Generative UI).
    /// Plan snapshots have media type application/json and contain a "steps" array.
    /// </summary>
    private static bool IsPlanStateSnapshot(DataContent dc)
    {
        if (dc.MediaType != "application/json" || dc.Data.Length == 0)
        {
            return false;
        }

        try
        {
            string text = System.Text.Encoding.UTF8.GetString(dc.Data.ToArray());
            using JsonDocument doc = JsonDocument.Parse(text);
            return doc.RootElement.TryGetProperty("steps", out _);
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Determines if DataContent represents a Plan state delta (JSON Patch).
    /// </summary>
    private static bool IsPlanStateDelta(DataContent dc)
    {
        return dc.MediaType == "application/json-patch+json" && dc.Data.Length > 0;
    }

    /// <summary>
    /// Attempts to parse a DataContent as a Plan snapshot.
    /// </summary>
    private static Plan? TryParsePlanSnapshot(DataContent dc)
    {
        try
        {
            string text = System.Text.Encoding.UTF8.GetString(dc.Data.ToArray());
            return JsonSerializer.Deserialize<Plan>(text, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Attempts to parse a DataContent as a list of JSON Patch operations.
    /// </summary>
    private static List<JsonPatchOperation>? TryParsePatchOperations(DataContent dc)
    {
        try
        {
            string text = System.Text.Encoding.UTF8.GetString(dc.Data.ToArray());
            return JsonSerializer.Deserialize<List<JsonPatchOperation>>(text, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Attempts to extract a DocumentState snapshot from DataContent (Predictive State Updates).
    /// Returns true if the DataContent is a valid DocumentState snapshot (contains "document" property).
    /// </summary>
    private static bool TryExtractDocumentSnapshot(DataContent dc, out DocumentState? documentState)
    {
        documentState = null;

        if (dc.MediaType != "application/json" || dc.Data.Length == 0)
        {
            return false;
        }

        try
        {
            string text = System.Text.Encoding.UTF8.GetString(dc.Data.ToArray());
            using JsonDocument doc = JsonDocument.Parse(text);

            // Verify this is a DocumentState (has "document" property but not "steps" or "ingredients")
            if (!doc.RootElement.TryGetProperty("document", out _))
            {
                return false;
            }

            // Exclude Plan snapshots (have "steps")
            if (doc.RootElement.TryGetProperty("steps", out _))
            {
                return false;
            }

            // Exclude Recipe snapshots (have "ingredients")
            if (doc.RootElement.TryGetProperty("ingredients", out _))
            {
                return false;
            }

            documentState = JsonSerializer.Deserialize<DocumentState>(text, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });

            return documentState is not null;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Consolidates DataContent in a message by replacing previous instance of same category.
    /// Categories are determined by media type and content structure (is_state_snapshot, json-patch, etc.)
    /// This prevents accumulating many redundant state updates in the DOM.
    /// </summary>
    private static void ConsolidateDataContent(ChatMessage message, DataContent newContent)
    {
        string category = GetDataContentCategory(newContent);
        
        // Find and replace existing DataContent of same category
        for (int i = 0; i < message.Contents.Count; i++)
        {
            if (message.Contents[i] is DataContent existing && GetDataContentCategory(existing) == category)
            {
                // Replace with newer content
                message.Contents[i] = newContent;
                return;
            }
        }
        
        // No existing content of this category, add new
        message.Contents.Add(newContent);
    }

    /// <summary>
    /// Determines the category of DataContent for consolidation purposes.
    /// Same category content will replace previous instances rather than accumulating.
    /// </summary>
    private static string GetDataContentCategory(DataContent dc)
    {
        // State deltas (JSON Patch) - consolidate per message
        if (dc.MediaType == "application/json-patch+json")
        {
            return "state-delta";
        }
        
        // State snapshots - consolidate per message
        if (dc.MediaType == "application/json" && dc.AdditionalProperties?.ContainsKey("is_state_snapshot") == true)
        {
            return "state-snapshot";
        }
        
        // Try to detect content type from JSON structure
        if (dc.MediaType == "application/json" && dc.Data.Length > 0)
        {
            try
            {
                string text = System.Text.Encoding.UTF8.GetString(dc.Data.ToArray());
                using JsonDocument doc = JsonDocument.Parse(text);
                
                // Plan snapshots
                if (doc.RootElement.TryGetProperty("steps", out _))
                {
                    return "plan-snapshot";
                }
                
                // Recipe snapshots
                if (doc.RootElement.TryGetProperty("ingredients", out _))
                {
                    return "recipe-snapshot";
                }
                
                // Document state snapshots
                if (doc.RootElement.TryGetProperty("document", out _))
                {
                    return "document-snapshot";
                }
            }
            catch
            {
                // Parsing failed, treat as generic
            }
        }
        
        // Generic DataContent - use media type as category
        return dc.MediaType ?? "unknown";
    }

    /// <summary>
    /// Determines if a FunctionResultContent represents a rejection response from HITL approval.
    /// Rejection responses have {"approved": false} in their Result.
    /// </summary>
    private static bool IsRejectionResponse(FunctionResultContent functionResult)
    {
        try
        {
            if (functionResult.Result is JsonElement jsonElement)
            {
                if (jsonElement.TryGetProperty("approved", out JsonElement approvedProp))
                {
                    return !approvedProp.GetBoolean();
                }
            }
        }
        catch
        {
            // Failed to parse result - treat as not a rejection
        }

        return false;
    }

    public void Dispose()
    {
        currentResponseCancellation?.Cancel();
        approvalTaskSource?.TrySetCanceled();
        throttleTimer?.Stop();
        throttleTimer?.Dispose();
    }
}
