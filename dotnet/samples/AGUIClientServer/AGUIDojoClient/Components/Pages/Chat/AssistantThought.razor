@* Copyright (c) Microsoft. All rights reserved. *@
@* MY CUSTOMIZATION POINT: Refactored to Accordion of Thought using BlazorBlueprint Collapsible + Accordion *@

@using System.Text.Json
@using AGUIDojoClient.Services
@using AGUIDojoClient.Models
@using BlazorBlueprint.Components.Accordion
@using BlazorBlueprint.Components.Badge
@using BlazorBlueprint.Components.Collapsible
@using BlazorBlueprint.Components.Spinner
@using BlazorBlueprint.Icons.Lucide.Components

@inject IToolComponentRegistry ToolRegistry

<div class="assistant-thought @(IsExpanded ? "expanded" : "collapsed")">
    @* MY CUSTOMIZATION POINT: BlazorBlueprint Collapsible replaces hand-rolled expand/collapse *@
    <Collapsible @bind-Open="IsExpanded">
        <CollapsibleTrigger AsChild>
            <button class="thought-toggle" type="button" aria-expanded="@IsExpanded">
                <LucideIcon Name="brain" Size="16" Class="thought-icon-lucide" />
                <span class="thought-summary">
                    @if (InProgress)
                    {
                        <span>Thinking...</span>
                    }
                    else
                    {
                        <span>Thinking (@GetStepCount() steps)</span>
                    }
                </span>
                <LucideIcon Name="@(IsExpanded ? "chevron-up" : "chevron-down")" Size="16" Class="thought-chevron-icon" />
            </button>
        </CollapsibleTrigger>
        <CollapsibleContent>
            <div class="thought-content">
                @{
                    var toolCallCycles = GetToolCallCycles();
                    var nonToolContents = GetNonToolCallContents();
                }

                @* MY CUSTOMIZATION POINT: BlazorBlueprint Accordion for individual tool call cycles *@
                @if (toolCallCycles.Count > 0)
                {
                    <Accordion Type="BlazorBlueprint.Primitives.Accordion.AccordionType.Multiple" Class="thought-accordion">
                        @foreach (var cycle in toolCallCycles)
                        {
                            <AccordionItem Value="@cycle.CallId" Class="thought-accordion-item">
                                <AccordionTrigger Class="thought-accordion-trigger">
                                    <div class="accordion-trigger-content">
                                        <LucideIcon Name="wrench" Size="14" Class="tool-icon-lucide" />
                                        <span class="tool-call-name">@cycle.Call.Name</span>
                                        @if (cycle.IsRunning)
                                        {
                                            <Badge Variant="BadgeVariant.Secondary" Class="tool-status-badge">
                                                <Spinner Size="SpinnerSize.Small" /> Running
                                            </Badge>
                                        }
                                        else if (cycle.IsRejected)
                                        {
                                            <Badge Variant="BadgeVariant.Destructive" Class="tool-status-badge">
                                                <LucideIcon Name="circle-x" Size="12" /> Rejected
                                            </Badge>
                                        }
                                        else if (cycle.HasResult)
                                        {
                                            <Badge Class="tool-status-badge">
                                                <LucideIcon Name="circle-check" Size="12" /> Completed
                                            </Badge>
                                            @if (cycle.Duration is not null)
                                            {
                                                <span class="tool-duration">@FormatDuration(cycle.Duration.Value)</span>
                                            }
                                        }
                                    </div>
                                </AccordionTrigger>
                                <AccordionContent Class="thought-accordion-content">
                                    @* Tool Call Arguments *@
                                    @if (cycle.Call.Arguments is { Count: > 0 })
                                    {
                                        <div class="tool-call-arguments">
                                            <div class="tool-section-label">
                                                <LucideIcon Name="list" Size="12" /> Arguments
                                            </div>
                                            @foreach (var arg in cycle.Call.Arguments)
                                            {
                                                <div class="tool-call-argument">
                                                    <span class="argument-name">@arg.Key:</span>
                                                    <span class="argument-value">@FormatArgumentValue(arg.Value)</span>
                                                </div>
                                            }
                                        </div>
                                    }
                                    @* Tool Call Result *@
                                    @if (cycle.Result is not null)
                                    {
                                        var toolInfo = GetToolRenderingInfo(cycle.Result);
                                        @if (toolInfo.HasComponent)
                                        {
                                            <div class="tool-result-section tool-result-section-dynamic">
                                                <div class="tool-section-label tool-section-label-dynamic">
                                                    <LucideIcon Name="sparkles" Size="12" /> @(toolInfo.ToolName ?? "Tool") Result
                                                </div>
                                                <div class="tool-result-data">
                                                    <DynamicComponent Type="toolInfo.ComponentType" Parameters="@(new Dictionary<string, object?> { { toolInfo.ParameterName!, toolInfo.ParsedData } })" />
                                                </div>
                                            </div>
                                        }
                                        else if (cycle.IsRejected)
                                        {
                                            <div class="tool-result-section tool-result-section-rejected">
                                                <div class="tool-section-label tool-section-label-rejected">
                                                    <LucideIcon Name="circle-x" Size="12" /> @(toolInfo.ToolName ?? "Tool") Rejected
                                                </div>
                                                <div class="tool-result-data">
                                                    @if (cycle.Result.Result is JsonElement rejJson)
                                                    {
                                                        <pre>@FormatJson(rejJson)</pre>
                                                    }
                                                    else if (cycle.Result.Result is not null)
                                                    {
                                                        <span>@cycle.Result.Result</span>
                                                    }
                                                    else
                                                    {
                                                        <span class="tool-result-empty">(no result)</span>
                                                    }
                                                </div>
                                            </div>
                                        }
                                        else
                                        {
                                            <div class="tool-result-section">
                                                <div class="tool-section-label">
                                                    <LucideIcon Name="circle-check" Size="12" /> @(toolInfo.ToolName ?? "Tool") Result
                                                </div>
                                                <div class="tool-result-data">
                                                    @if (cycle.Result.Result is JsonElement resJson)
                                                    {
                                                        <pre>@FormatJson(resJson)</pre>
                                                    }
                                                    else if (cycle.Result.Result is not null)
                                                    {
                                                        <span>@cycle.Result.Result</span>
                                                    }
                                                    else
                                                    {
                                                        <span class="tool-result-empty">(no result)</span>
                                                    }
                                                </div>
                                            </div>
                                        }
                                    }
                                    else if (cycle.IsRunning)
                                    {
                                        <div class="tool-result-section tool-result-section-pending">
                                        <Spinner Size="SpinnerSize.Small" />
                                            <span class="tool-waiting-text">Waiting for result...</span>
                                        </div>
                                    }
                                </AccordionContent>
                            </AccordionItem>
                        }
                    </Accordion>
                }

                @* Non-tool-call items: DataContent, ErrorContent *@
                @foreach (var content in nonToolContents)
                {
                    @switch (content)
                    {
                        case DataContent dc when IsStateSnapshot(dc):
                            <div class="assistant-state-snapshot">
                                <div class="state-snapshot-icon">
                                    <LucideIcon Name="database" Size="14" />
                                </div>
                                <div class="state-snapshot-content">
                                    <div class="state-snapshot-header">State Snapshot</div>
                                    <div class="state-snapshot-data">
                                        <pre>@FormatDataContent(dc)</pre>
                                    </div>
                                </div>
                            </div>
                            break;

                        case DataContent dc when IsStateDelta(dc):
                            <div class="assistant-state-delta">
                                <div class="state-delta-icon">
                                    <LucideIcon Name="arrow-right-left" Size="14" />
                                </div>
                                <div class="state-delta-content">
                                    <div class="state-delta-header">State Update (JSON Patch)</div>
                                    <div class="state-delta-data">
                                        <pre>@FormatDataContent(dc)</pre>
                                    </div>
                                </div>
                            </div>
                            break;

                        case DataContent dc:
                            <div class="assistant-data-content">
                                <div class="data-content-icon">
                                    <LucideIcon Name="file-text" Size="14" />
                                </div>
                                <div class="data-content-content">
                                    <div class="data-content-header">Data (@(dc.MediaType ?? "unknown"))</div>
                                    <div class="data-content-data">
                                        <pre>@FormatDataContent(dc)</pre>
                                    </div>
                                </div>
                            </div>
                            break;

                        case ErrorContent ec:
                            <div class="assistant-error">
                                <div class="error-icon">
                                    <LucideIcon Name="triangle-alert" Size="14" />
                                </div>
                                <div class="error-content">
                                    <div class="error-header">
                                        Error
                                        @if (!string.IsNullOrEmpty(ec.ErrorCode))
                                        {
                                            <span class="error-code">(@ec.ErrorCode)</span>
                                        }
                                    </div>
                                    <div class="error-message">@ec.Message</div>
                                </div>
                            </div>
                            break;
                    }
                }
            </div>
        </CollapsibleContent>
    </Collapsible>
</div>

@code {
    /// <summary>
    /// The thought contents to display (FunctionCallContent, FunctionResultContent, DataContent, ErrorContent).
    /// </summary>
    [Parameter, EditorRequired]
    public required IEnumerable<AIContent> ThoughtContents { get; set; }

    /// <summary>
    /// All contents from the parent message - used for tool name lookups.
    /// </summary>
    [Parameter, EditorRequired]
    public required IEnumerable<AIContent> AllContents { get; set; }

    /// <summary>
    /// Whether the message is still being streamed (in progress).
    /// When in progress, the thought block is expanded by default.
    /// </summary>
    [Parameter]
    public bool InProgress { get; set; }

    // MY CUSTOMIZATION POINT: Optional reasoning steps for timing display from ObservabilityService
    /// <summary>
    /// Optional reasoning steps from ObservabilityService for timing display.
    /// When provided, each tool call accordion item shows execution duration.
    /// Wired in by task-13 integration.
    /// </summary>
    [Parameter]
    public IReadOnlyList<ReasoningStep>? ReasoningSteps { get; set; }

    /// <summary>
    /// Tracks whether the thought block is expanded or collapsed.
    /// Default: expanded during streaming, collapsed after completion.
    /// Bound to BlazorBlueprint Collapsible via @bind-Open.
    /// </summary>
    private bool IsExpanded { get; set; } = true;

    private bool _previousInProgress = true;

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        // Auto-collapse when streaming completes (InProgress transitions from true to false)
        if (_previousInProgress && !InProgress)
        {
            IsExpanded = false;
        }
        _previousInProgress = InProgress;
    }

    /// <summary>
    /// Gets the count of "steps" (thought items) for the summary display.
    /// </summary>
    private int GetStepCount()
    {
        return ThoughtContents.Count();
    }

    // MY CUSTOMIZATION POINT: Tool call cycle grouping for Accordion of Thought

    /// <summary>
    /// Groups FunctionCallContent with their matching FunctionResultContent into tool call cycles.
    /// Each cycle becomes one AccordionItem in the Accordion of Thought.
    /// </summary>
    private List<ToolCallCycle> GetToolCallCycles()
    {
        var cycles = new List<ToolCallCycle>();
        var resultMap = new Dictionary<string, FunctionResultContent>();

        // Build result lookup by CallId
        foreach (var content in ThoughtContents)
        {
            if (content is FunctionResultContent frc && frc.CallId is not null)
            {
                resultMap[frc.CallId] = frc;
            }
        }

        // Build cycles from FunctionCallContent entries
        foreach (var content in ThoughtContents)
        {
            if (content is FunctionCallContent fcc && fcc.CallId is not null)
            {
                resultMap.TryGetValue(fcc.CallId, out var result);
                var isRejected = result is not null && IsRejectionResult(result);
                var duration = GetStepDuration(fcc.CallId);

                cycles.Add(new ToolCallCycle(
                    CallId: fcc.CallId,
                    Call: fcc,
                    Result: result,
                    IsRunning: result is null && InProgress,
                    HasResult: result is not null,
                    IsRejected: isRejected,
                    Duration: duration
                ));
            }
        }

        return cycles;
    }

    /// <summary>
    /// Gets non-tool-call contents (DataContent, ErrorContent) for flat rendering below the accordion.
    /// </summary>
    private IEnumerable<AIContent> GetNonToolCallContents()
    {
        return ThoughtContents.Where(c => c is not FunctionCallContent and not FunctionResultContent);
    }

    /// <summary>
    /// Gets the execution duration for a tool call from the optional ReasoningSteps parameter.
    /// </summary>
    private TimeSpan? GetStepDuration(string callId)
    {
        return ReasoningSteps?.FirstOrDefault(s => s.Id == callId)?.Duration;
    }

    /// <summary>
    /// Formats a TimeSpan duration for display (e.g., "245ms", "1.2s").
    /// </summary>
    private static string FormatDuration(TimeSpan duration)
    {
        if (duration.TotalMilliseconds < 1000)
        {
            return $"{duration.TotalMilliseconds:F0}ms";
        }

        return $"{duration.TotalSeconds:F1}s";
    }

    /// <summary>
    /// Formats a function argument value for display.
    /// </summary>
    private static string FormatArgumentValue(object? value)
    {
        if (value is null)
        {
            return "(null)";
        }

        if (value is JsonElement json)
        {
            return json.ValueKind == JsonValueKind.String
                ? json.GetString() ?? "(null)"
                : json.ToString();
        }

        return value.ToString() ?? "(null)";
    }

    /// <summary>
    /// Formats a JsonElement for display with indentation.
    /// </summary>
    private static string FormatJson(JsonElement json)
    {
        try
        {
            return JsonSerializer.Serialize(json, new JsonSerializerOptions { WriteIndented = true });
        }
        catch
        {
            return json.ToString();
        }
    }

    /// <summary>
    /// Formats DataContent for display.
    /// </summary>
    private static string FormatDataContent(DataContent dc)
    {
        if (dc.Data.Length == 0)
        {
            return "(no data)";
        }

        try
        {
            string text = System.Text.Encoding.UTF8.GetString(dc.Data.ToArray());

            if (dc.MediaType?.Contains("json", StringComparison.OrdinalIgnoreCase) == true)
            {
                var jsonDoc = JsonDocument.Parse(text);
                return JsonSerializer.Serialize(jsonDoc, new JsonSerializerOptions { WriteIndented = true });
            }

            return text;
        }
        catch
        {
            return $"[Binary data: {dc.Data.Length} bytes]";
        }
    }

    /// <summary>
    /// Determines if DataContent represents a state snapshot.
    /// </summary>
    private static bool IsStateSnapshot(DataContent dc)
    {
        return dc.MediaType == "application/json" &&
               dc.AdditionalProperties?.ContainsKey("is_state_snapshot") == true;
    }

    /// <summary>
    /// Determines if DataContent represents a state delta (JSON Patch).
    /// </summary>
    private static bool IsStateDelta(DataContent dc)
    {
        return dc.MediaType == "application/json-patch+json" ||
               (dc.MediaType == "application/json" && dc.AdditionalProperties?.ContainsKey("is_state_delta") == true);
    }

    /// <summary>
    /// Determines if a FunctionResultContent represents a rejection/denial.
    /// </summary>
    private static bool IsRejectionResult(FunctionResultContent frc)
    {
        string? resultText = frc.Result switch
        {
            string s => s,
            JsonElement je when je.ValueKind == JsonValueKind.String => je.GetString(),
            JsonElement je => je.ToString(),
            _ => frc.Result?.ToString()
        };

        if (string.IsNullOrWhiteSpace(resultText))
        {
            return false;
        }

        return resultText.Contains("rejected", StringComparison.OrdinalIgnoreCase) ||
               resultText.Contains("denied", StringComparison.OrdinalIgnoreCase) ||
               resultText.Contains("cancelled", StringComparison.OrdinalIgnoreCase) ||
               resultText.Contains("canceled", StringComparison.OrdinalIgnoreCase) ||
               resultText.Contains("declined", StringComparison.OrdinalIgnoreCase) ||
               resultText.Contains("\"approved\":false", StringComparison.OrdinalIgnoreCase) ||
               resultText.Contains("\"approved\": false", StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Gets all information needed to render a tool result.
    /// </summary>
    private ToolRenderingInfo GetToolRenderingInfo(FunctionResultContent frc)
    {
        string? toolName = GetToolNameForResult(frc);
        if (string.IsNullOrWhiteSpace(toolName))
        {
            return new ToolRenderingInfo(null, null, null, null);
        }

        if (!ToolRegistry.TryGetComponent(toolName, out Type? componentType) || componentType is null)
        {
            return new ToolRenderingInfo(toolName, null, null, null);
        }

        if (!ToolRegistry.TryGetParameterName(toolName, out string? parameterName) || parameterName is null)
        {
            return new ToolRenderingInfo(toolName, null, null, null);
        }

        object? parsedData = TryParseToolResult(toolName, frc);
        if (parsedData is null)
        {
            return new ToolRenderingInfo(toolName, null, null, null);
        }

        return new ToolRenderingInfo(toolName, componentType, parameterName, parsedData);
    }

    /// <summary>
    /// Gets the tool name for a FunctionResultContent by finding the matching FunctionCallContent.
    /// </summary>
    private string? GetToolNameForResult(FunctionResultContent frc)
    {
        if (frc.CallId is null)
        {
            return null;
        }

        foreach (AIContent content in AllContents)
        {
            if (content is FunctionCallContent fcc && fcc.CallId == frc.CallId)
            {
                return fcc.Name;
            }
        }

        return null;
    }

    /// <summary>
    /// Attempts to parse a FunctionResultContent for the specified tool type.
    /// </summary>
    private static object? TryParseToolResult(string toolName, FunctionResultContent frc)
    {
        try
        {
            JsonElement? jsonElement = frc.Result switch
            {
                JsonElement je => je,
                string s when !string.IsNullOrWhiteSpace(s) && IsValidJson(s) => JsonDocument.Parse(s).RootElement,
                _ => null
            };

            if (jsonElement is null)
            {
                return null;
            }

            JsonSerializerOptions options = new() { PropertyNameCaseInsensitive = true };

            return toolName.ToLowerInvariant() switch
            {
                "get_weather" => TryDeserializeWeatherInfo(jsonElement.Value, options),
                _ => null
            };
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Checks if a string is valid JSON.
    /// </summary>
    private static bool IsValidJson(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return false;
        }

        char firstChar = value.TrimStart()[0];
        if (firstChar != '{' && firstChar != '[' && firstChar != '"' &&
            !char.IsDigit(firstChar) && firstChar != '-' &&
            firstChar != 't' && firstChar != 'f' && firstChar != 'n')
        {
            return false;
        }

        try
        {
            using JsonDocument _ = JsonDocument.Parse(value);
            return true;
        }
        catch (JsonException)
        {
            return false;
        }
    }

    /// <summary>
    /// Attempts to deserialize a JsonElement as WeatherInfo.
    /// </summary>
    private static WeatherInfo? TryDeserializeWeatherInfo(JsonElement json, JsonSerializerOptions options)
    {
        if (json.TryGetProperty("temperature", out _) &&
            json.TryGetProperty("conditions", out _))
        {
            return json.Deserialize<WeatherInfo>(options);
        }
        return null;
    }

    // MY CUSTOMIZATION POINT: Record for grouping FunctionCallContent + FunctionResultContent into accordion items

    /// <summary>
    /// Represents a grouped tool call cycle: a FunctionCallContent paired with its matching FunctionResultContent.
    /// </summary>
    private sealed record ToolCallCycle(
        string CallId,
        FunctionCallContent Call,
        FunctionResultContent? Result,
        bool IsRunning,
        bool HasResult,
        bool IsRejected,
        TimeSpan? Duration);

    /// <summary>
    /// Contains all information needed to render a tool result.
    /// </summary>
    private sealed record ToolRenderingInfo(string? ToolName, Type? ComponentType, string? ParameterName, object? ParsedData)
    {
        public bool HasComponent => ComponentType is not null && ParsedData is not null;
    }
}
