@using System.Runtime.CompilerServices
@using System.Text
@using System.Text.Json
@using System.Text.RegularExpressions
@using Microsoft.Extensions.Logging
@inject ILogger<ChatMessageItem> Logger

@if (Message.Role == ChatRole.User)
{
    <div class="user-message">
        @Message.Text
    </div>
}
else if (Message.Role == ChatRole.Assistant || Message.Role == ChatRole.System || Message.Role == ChatRole.Tool)
{
    Logger.LogInformation("[ChatMessageItem] Rendering message: Role={Role}, Contents={Count}", Message.Role, Message.Contents.Count);
    foreach (var content in Message.Contents)
    {
        Logger.LogInformation("[ChatMessageItem] Processing content: Type={Type}", content.GetType().Name);
        if (Message.Role == ChatRole.Assistant && content is TextContent { Text: { Length: > 0 } text })
        {
            <div class="assistant-message">
                <div>
                    <div class="assistant-message-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18" />
                        </svg>
                    </div>
                </div>
                <div class="assistant-message-header">Assistant</div>
                <div class="assistant-message-text">
                    <div>@((MarkupString)text)</div>
                </div>
            </div>
        }
        else if (content is DataContent dataContent)
        {
            var stateText = FormatDataContent(dataContent);
            if (!string.IsNullOrWhiteSpace(stateText))
            {
                <div class="assistant-message assistant-state">
                    <div>
                        <div class="assistant-message-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 6.75h15m-15 4.5h15m-15 4.5h15" />
                            </svg>
                        </div>
                    </div>
                    <div class="assistant-message-header">State Update</div>
                    <div class="assistant-message-text">
                        <div><strong>Media type:</strong> @(dataContent.MediaType ?? "application/octet-stream")</div>
                        <pre>@stateText</pre>
                    </div>
                </div>
            }
        }
        else if (content is FunctionCallContent toolCall)
        {
            TrackFunctionCall(toolCall);
            Logger.LogInformation("[ChatMessageItem] Rendering tool call: {Name} (CallId={CallId})", toolCall.Name, toolCall.CallId);
            string mediaType = toolCall.Name == "get_weather"
                ? ToolContentMediaTypes.WeatherCall
                : ToolContentMediaTypes.ToolCall;
            Logger.LogInformation("[ChatMessageItem] Using media type: {MediaType}", mediaType);
            <DynamicMessageRenderer Data="@toolCall" MediaType="@mediaType" />
        }
        else if (content is FunctionResultContent funcResult)
        {
            TrackFunctionResult(funcResult);
            Logger.LogInformation("[ChatMessageItem] Rendering tool result: CallId={CallId}", funcResult.CallId);
            
            // Check if this result matches a weather call - if so, suppress separate rendering
            // because the weather call component will display both call and result
            if (TryGetMatchingCall(funcResult.CallId, out FunctionCallContent? call) && call?.Name == "get_weather")
            {
                Logger.LogInformation("[ChatMessageItem] Weather result matched to call - suppressing separate render");
                // Don't render separately - the WeatherToolComponent for the call will show the result
            }
            else
            {
                string mediaType = ToolContentMediaTypes.ToolResult;
                Logger.LogInformation("[ChatMessageItem] Using media type: {MediaType} for result", mediaType);
                <DynamicMessageRenderer Data="@funcResult" MediaType="@mediaType" />
            }
        }
    }
}

@code {
    private static readonly ConditionalWeakTable<ChatMessage, ChatMessageItem> SubscribersLookup = new();
    private static readonly Regex Base64Regex = new("^[A-Za-z0-9+/]*={0,2}$", RegexOptions.Compiled);
    private static readonly Dictionary<string, FunctionCallContent> FunctionCalls = new(StringComparer.Ordinal);
    private static readonly Dictionary<string, FunctionResultContent> FunctionResults = new(StringComparer.Ordinal);
    private static readonly Dictionary<string, WeakReference<ChatMessageItem>> FunctionCallSubscribers = new(StringComparer.Ordinal);

    private int _lastMessageHash;
    private bool _lastInProgress;

    [Parameter, EditorRequired]
    public required ChatMessage Message { get; set; }

    [Parameter]
    public bool InProgress { get; set;}

    protected override void OnInitialized()
    {
        SubscribersLookup.AddOrUpdate(Message, this);
    }

    protected override bool ShouldRender()
    {
        // Compute hash of current message state
        int currentHash = ComputeMessageHash();
        
        // Only re-render if message content or InProgress state has changed
        if (currentHash == _lastMessageHash && InProgress == _lastInProgress)
        {
            Logger.LogDebug("[ChatMessageItem] Skipping redundant render for message: Role={Role}", Message.Role);
            return false;
        }
        
        // Update tracking state
        _lastMessageHash = currentHash;
        _lastInProgress = InProgress;
        
        return true;
    }

    private int ComputeMessageHash()
    {
        var hash = new HashCode();
        hash.Add(Message.Role);
        hash.Add(Message.Text);
        hash.Add(Message.Contents.Count);
        
        // Include content identifiers to detect changes
        foreach (var content in Message.Contents)
        {
            hash.Add(content.GetType());
            
            if (content is FunctionCallContent call)
            {
                hash.Add(call.CallId);
                hash.Add(call.Name);
            }
            else if (content is FunctionResultContent result)
            {
                hash.Add(result.CallId);
                // Hash the result content to detect changes
                hash.Add(result.Result?.ToString() ?? string.Empty);
            }
            else if (content is TextContent text)
            {
                hash.Add(text.Text);
            }
        }
        
        return hash.ToHashCode();
    }

    public static void NotifyChanged(ChatMessage source)
    {
        if (SubscribersLookup.TryGetValue(source, out var subscriber))
        {
            subscriber.StateHasChanged();
        }
    }

    private static string FormatDataContent(DataContent dataContent)
    {
        string raw = GetDataContentText(dataContent);
        if (string.IsNullOrWhiteSpace(raw))
        {
            return string.Empty;
        }

        if (dataContent.MediaType?.Contains("json", StringComparison.OrdinalIgnoreCase) == true)
        {
            try
            {
                using JsonDocument document = JsonDocument.Parse(raw);
                return JsonSerializer.Serialize(document.RootElement, new JsonSerializerOptions { WriteIndented = true });
            }
            catch (JsonException)
            {
                return raw;
            }
        }

        return raw;
    }

    private static string GetDataContentText(DataContent dataContent)
    {
        string raw = dataContent.Base64Data.ToString();
        if (string.IsNullOrWhiteSpace(raw) && dataContent.Uri is not null)
        {
            return dataContent.Uri.ToString();
        }

        if (IsLikelyBase64(raw))
        {
            try
            {
                return Encoding.UTF8.GetString(Convert.FromBase64String(raw));
            }
            catch (FormatException)
            {
                return raw;
            }
        }

        return raw;
    }

    private static bool IsLikelyBase64(string value)
    {
        return !string.IsNullOrWhiteSpace(value)
            && value.Length % 4 == 0
            && Base64Regex.IsMatch(value);
    }

    private void TrackFunctionCall(FunctionCallContent call)
    {
        FunctionCalls[call.CallId] = call;
        FunctionCallSubscribers[call.CallId] = new WeakReference<ChatMessageItem>(this);
    }

    private void TrackFunctionResult(FunctionResultContent result)
    {
        // Only notify if this is a new result (not already tracked)
        bool isNewResult = !FunctionResults.ContainsKey(result.CallId);
        Logger.LogInformation("[ChatMessageItem.TrackFunctionResult] CallId={CallId}, IsNew={IsNew}, TotalResults={Total}", 
            result.CallId, isNewResult, FunctionResults.Count);
        FunctionResults[result.CallId] = result;
        
        if (isNewResult)
        {
            Logger.LogInformation("[ChatMessageItem.TrackFunctionResult] Notifying subscriber for CallId={CallId}", result.CallId);
            NotifyCallSubscriber(result.CallId);
        }
    }

    internal static FunctionResultContent? GetMatchingResult(string callId)
    {
        bool found = FunctionResults.TryGetValue(callId, out FunctionResultContent? result);
        // Don't log here as it's called on every render - would flood logs
        return result;
    }

    internal static bool TryGetMatchingCall(string callId, out FunctionCallContent? call)
    {
        return FunctionCalls.TryGetValue(callId, out call);
    }

    private static void NotifyCallSubscriber(string callId)
    {
        if (!FunctionCallSubscribers.TryGetValue(callId, out WeakReference<ChatMessageItem>? subscriber))
        {
            // Logger not available in static context - this is expected for non-weather tools
            return;
        }

        if (subscriber.TryGetTarget(out ChatMessageItem? target))
        {
            target.Logger.LogInformation("[NotifyCallSubscriber] Triggering StateHasChanged for CallId={CallId}", callId);
            target.StateHasChanged();
        }
        else
        {
            FunctionCallSubscribers.Remove(callId);
        }
    }
}
