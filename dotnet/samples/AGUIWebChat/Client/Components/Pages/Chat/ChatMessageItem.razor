@using System.Runtime.CompilerServices
@using System.Text
@using System.Text.Json
@using System.Text.RegularExpressions
@using Microsoft.Extensions.Logging
@inject ILogger<ChatMessageItem> Logger

@if (Message.Role == ChatRole.User)
{
    <div class="user-message">
        @Message.Text
    </div>
}
else if (Message.Role == ChatRole.Assistant || Message.Role == ChatRole.System || Message.Role == ChatRole.Tool)
{
    Logger.LogInformation("[ChatMessageItem] Rendering message: Role={Role}, Contents={Count}", Message.Role, Message.Contents.Count);
    foreach (var content in SortedContents)
    {
        Logger.LogInformation("[ChatMessageItem] Processing content: Type={Type}", content.GetType().Name);
        if (Message.Role == ChatRole.Assistant && content is TextContent { Text: { Length: > 0 } text })
        {
            // CRITICAL FIX: Filter out quiz JSON duplication
            // The server may include quiz JSON in assistant text after tool results
            // We need to suppress this to avoid duplicate rendering
            if (IsQuizJsonDuplicate(text))
            {
                Logger.LogInformation("[ChatMessageItem] Detected quiz JSON in assistant text - suppressing duplicate rendering");
                continue; // Skip rendering this text content
            }

            <div class="assistant-message">
                <div>
                    <div class="assistant-message-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18" />
                        </svg>
                    </div>
                </div>
                <div class="assistant-message-header">Assistant</div>
                <div class="assistant-message-text">
                    <div>@((MarkupString)text)</div>
                </div>
            </div>
        }
        else if (content is DataContent dataContent)
        {
            // FEATURE: Handle plan DataContent inline rendering
            if (dataContent.MediaType == "application/vnd.microsoft.agui.plan+json")
            {
                Logger.LogInformation("[ChatMessageItem] Rendering plan DataContent inline");
                try
                {
                    // Get plan JSON using existing helper
                    string planJson = GetDataContentText(dataContent);

                    if (!string.IsNullOrWhiteSpace(planJson))
                    {
                        var planContent = JsonSerializer.Deserialize<AGUIWebChatClient.Components.Pages.Chat.PlanContent>(
                            planJson,
                            new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

                        if (planContent is not null)
                        {
                            Logger.LogInformation("[ChatMessageItem] Successfully deserialized plan - rendering PlanComponent");
                            <DynamicMessageRenderer Data="@planContent" MediaType="@dataContent.MediaType" />
                        }
                        else
                        {
                            Logger.LogWarning("[ChatMessageItem] Failed to deserialize plan JSON");
                        }
                    }
                    else
                    {
                        Logger.LogWarning("[ChatMessageItem] Plan DataContent has empty data");
                    }
                }
                catch (JsonException ex)
                {
                    Logger.LogError(ex, "[ChatMessageItem] Error deserializing plan JSON: {Message}", ex.Message);
                }
            }
            else
            {
                // Other DataContent types - render as state update
                var stateText = FormatDataContent(dataContent);
                if (!string.IsNullOrWhiteSpace(stateText))
                {
                    <div class="assistant-message assistant-state">
                        <div>
                            <div class="assistant-message-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 6.75h15m-15 4.5h15m-15 4.5h15" />
                                </svg>
                            </div>
                        </div>
                        <div class="assistant-message-header">State Update</div>
                        <div class="assistant-message-text">
                            <div><strong>Media type:</strong> @(dataContent.MediaType ?? "application/octet-stream")</div>
                            <pre>@stateText</pre>
                        </div>
                    </div>
                }
            }
        }
        else if (content is FunctionCallContent toolCall)
        {
            TrackFunctionCall(toolCall);
            Logger.LogInformation("[ChatMessageItem] Rendering tool call: {Name} (CallId={CallId})", toolCall.Name, toolCall.CallId);
            string mediaType = toolCall.Name switch
            {
                "get_weather" => ToolContentMediaTypes.WeatherCall,
                "create_plan" => ToolContentMediaTypes.PlanCall,
                "update_plan_step" => ToolContentMediaTypes.PlanUpdateCall,
                "generate_quiz" => ToolContentMediaTypes.ToolCall,
                _ => ToolContentMediaTypes.ToolCall
            };
            Logger.LogInformation("[ChatMessageItem] Using media type: {MediaType}", mediaType);
            <DynamicMessageRenderer Data="@toolCall" MediaType="@mediaType" />
        }
        else if (content is FunctionResultContent funcResult)
        {
            TrackFunctionResult(funcResult);
            Logger.LogInformation("[ChatMessageItem] Rendering tool result: CallId={CallId}", funcResult.CallId);
            
            // Check if this result matches a weather call - if so, suppress separate rendering
            // because the weather call component will display both call and result
            if (TryGetMatchingCall(funcResult.CallId, out FunctionCallContent? call) && call?.Name == "get_weather")
            {
                Logger.LogInformation("[ChatMessageItem] Weather result matched to call - suppressing separate render");
                // Don't render separately - the WeatherToolComponent for the call will show the result
            }
            else if (TryGetMatchingCall(funcResult.CallId, out FunctionCallContent? quizCall) && (quizCall?.Name == "generate_quiz" || quizCall?.Name == "get_quiz"))
            {
                // Parse quiz JSON result and render as Quiz component ONLY (no raw JSON fallback)
                Logger.LogInformation("[ChatMessageItem] Routing {ToolName} result to Quiz component", quizCall.Name);
                try
                {
                    string quizJson = funcResult.Result?.ToString() ?? string.Empty;
                    var quiz = JsonSerializer.Deserialize<AGUIWebChat.Client.Models.QuizModels.Quiz>(quizJson, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    if (quiz is not null)
                    {
                        Logger.LogInformation("[ChatMessageItem] Successfully deserialized quiz JSON - rendering QuizComponent");
                        <DynamicMessageRenderer Data="@quiz" MediaType="@ToolContentMediaTypes.Quiz" />
                    }
                    else
                    {
                        Logger.LogWarning("[ChatMessageItem] Failed to deserialize quiz JSON - quiz deserialized to null. NOT rendering raw JSON.");
                        // Do NOT render raw JSON fallback - suppress display entirely
                    }
                }
                catch (JsonException ex)
                {
                    Logger.LogError(ex, "[ChatMessageItem] Error deserializing quiz JSON: {Message}. NOT rendering raw JSON.", ex.Message);
                    // Do NOT render raw JSON fallback - suppress display entirely
                }
            }
            else
            {
                // Route plan tool results to specialized media type
                string mediaType = TryGetMatchingCall(funcResult.CallId, out FunctionCallContent? matchingCall) && 
                                   (matchingCall?.Name == "create_plan" || matchingCall?.Name == "update_plan_step")
                    ? ToolContentMediaTypes.PlanResult
                    : ToolContentMediaTypes.ToolResult;
                Logger.LogInformation("[ChatMessageItem] Using media type: {MediaType} for result", mediaType);
                <DynamicMessageRenderer Data="@funcResult" MediaType="@mediaType" />
            }
        }
    }
}

@code {
    private static readonly ConditionalWeakTable<ChatMessage, ChatMessageItem> SubscribersLookup = new();
    private static readonly Regex Base64Regex = new("^[A-Za-z0-9+/]*={0,2}$", RegexOptions.Compiled);
    private static readonly Dictionary<string, FunctionCallContent> FunctionCalls = new(StringComparer.Ordinal);
    private static readonly Dictionary<string, FunctionResultContent> FunctionResults = new(StringComparer.Ordinal);
    private static readonly Dictionary<string, WeakReference<ChatMessageItem>> FunctionCallSubscribers = new(StringComparer.Ordinal);

    private int _lastMessageHash;
    private bool _lastInProgress;

    [Parameter, EditorRequired]
    public required ChatMessage Message { get; set; }

    private IEnumerable<AIContent> SortedContents
    {
        get
        {
            // Group contents by type
            var calls = Message.Contents.OfType<FunctionCallContent>().ToList();
            var results = Message.Contents.OfType<FunctionResultContent>().ToList();
            var texts = Message.Contents.OfType<TextContent>().ToList();
            var data = Message.Contents.OfType<DataContent>().ToList();
            
            // Return in strict order: calls -> results -> texts/data
            return calls.Cast<AIContent>()
                .Concat(results.Cast<AIContent>())
                .Concat(texts.Cast<AIContent>())
                .Concat(data.Cast<AIContent>());
        }
    }

    [Parameter]
    public bool InProgress { get; set;}

    protected override void OnInitialized()
    {
        SubscribersLookup.AddOrUpdate(Message, this);
    }

    protected override bool ShouldRender()
    {
        // Compute hash of current message state
        int currentHash = ComputeMessageHash();
        
        // Only re-render if message content or InProgress state has changed
        if (currentHash == _lastMessageHash && InProgress == _lastInProgress)
        {
            Logger.LogDebug("[ChatMessageItem] Skipping redundant render for message: Role={Role}", Message.Role);
            return false;
        }
        
        // Update tracking state
        _lastMessageHash = currentHash;
        _lastInProgress = InProgress;
        
        return true;
    }

    private int ComputeMessageHash()
    {
        var hash = new HashCode();
        hash.Add(Message.Role);
        hash.Add(Message.Text);
        hash.Add(Message.Contents.Count);
        
        // Include content identifiers to detect changes
        foreach (var content in Message.Contents)
        {
            hash.Add(content.GetType());
            
            if (content is FunctionCallContent call)
            {
                hash.Add(call.CallId);
                hash.Add(call.Name);
            }
            else if (content is FunctionResultContent result)
            {
                hash.Add(result.CallId);
                // Hash the result content to detect changes
                hash.Add(result.Result?.ToString() ?? string.Empty);
            }
            else if (content is TextContent text)
            {
                hash.Add(text.Text);
            }
        }
        
        return hash.ToHashCode();
    }

    public static void NotifyChanged(ChatMessage source)
    {
        if (SubscribersLookup.TryGetValue(source, out var subscriber))
        {
            subscriber.StateHasChanged();
        }
    }

    private static string FormatDataContent(DataContent dataContent)
    {
        string raw = GetDataContentText(dataContent);
        if (string.IsNullOrWhiteSpace(raw))
        {
            return string.Empty;
        }

        if (dataContent.MediaType?.Contains("json", StringComparison.OrdinalIgnoreCase) == true)
        {
            try
            {
                using JsonDocument document = JsonDocument.Parse(raw);
                return JsonSerializer.Serialize(document.RootElement, new JsonSerializerOptions { WriteIndented = true });
            }
            catch (JsonException)
            {
                return raw;
            }
        }

        return raw;
    }

    private static string GetDataContentText(DataContent dataContent)
    {
        string raw = dataContent.Base64Data.ToString();
        if (string.IsNullOrWhiteSpace(raw) && dataContent.Uri is not null)
        {
            return dataContent.Uri.ToString();
        }

        if (IsLikelyBase64(raw))
        {
            try
            {
                return Encoding.UTF8.GetString(Convert.FromBase64String(raw));
            }
            catch (FormatException)
            {
                return raw;
            }
        }

        return raw;
    }

    private static bool IsLikelyBase64(string value)
    {
        return !string.IsNullOrWhiteSpace(value)
            && value.Length % 4 == 0
            && Base64Regex.IsMatch(value);
    }

    private void TrackFunctionCall(FunctionCallContent call)
    {
        FunctionCalls[call.CallId] = call;
        FunctionCallSubscribers[call.CallId] = new WeakReference<ChatMessageItem>(this);
    }

    private void TrackFunctionResult(FunctionResultContent result)
    {
        // Only notify if this is a new result (not already tracked)
        bool isNewResult = !FunctionResults.ContainsKey(result.CallId);
        Logger.LogInformation("[ChatMessageItem.TrackFunctionResult] CallId={CallId}, IsNew={IsNew}, TotalResults={Total}", 
            result.CallId, isNewResult, FunctionResults.Count);
        FunctionResults[result.CallId] = result;
        
        if (isNewResult)
        {
            Logger.LogInformation("[ChatMessageItem.TrackFunctionResult] Notifying subscriber for CallId={CallId}", result.CallId);
            NotifyCallSubscriber(result.CallId);
        }
    }

    internal static FunctionResultContent? GetMatchingResult(string callId)
    {
        bool found = FunctionResults.TryGetValue(callId, out FunctionResultContent? result);
        // Don't log here as it's called on every render - would flood logs
        return result;
    }

    internal static bool TryGetMatchingCall(string callId, out FunctionCallContent? call)
    {
        return FunctionCalls.TryGetValue(callId, out call);
    }

    private static void NotifyCallSubscriber(string callId)
    {
        if (!FunctionCallSubscribers.TryGetValue(callId, out WeakReference<ChatMessageItem>? subscriber))
        {
            // Logger not available in static context - this is expected for non-weather tools
            return;
        }

        if (subscriber.TryGetTarget(out ChatMessageItem? target))
        {
            target.Logger.LogInformation("[NotifyCallSubscriber] Triggering StateHasChanged for CallId={CallId}", callId);
            target.StateHasChanged();
        }
        else
        {
            FunctionCallSubscribers.Remove(callId);
        }
    }

    private bool IsQuizJsonDuplicate(string text)
    {
        // Check if this message contains quiz tool results
        bool hasQuizResults = Message.Contents
            .OfType<FunctionResultContent>()
            .Any(result => TryGetMatchingCall(result.CallId, out FunctionCallContent? call) && call?.Name == "generate_quiz");

        if (!hasQuizResults)
        {
            // No quiz results in this message - text is not a duplicate
            return false;
        }

        // Try to parse the text as quiz JSON
        try
        {
            // Clean up potential markdown formatting (```json ... ```)
            string cleanedText = text.Trim();
            if (cleanedText.StartsWith("```json", StringComparison.OrdinalIgnoreCase))
            {
                // Extract JSON from markdown code block
                int startIndex = cleanedText.IndexOf('\n') + 1;
                int endIndex = cleanedText.LastIndexOf("```");
                if (endIndex > startIndex)
                {
                    cleanedText = cleanedText.Substring(startIndex, endIndex - startIndex).Trim();
                }
            }
            else if (cleanedText.StartsWith("```", StringComparison.Ordinal))
            {
                // Generic code block
                int startIndex = cleanedText.IndexOf('\n') + 1;
                int endIndex = cleanedText.LastIndexOf("```");
                if (endIndex > startIndex)
                {
                    cleanedText = cleanedText.Substring(startIndex, endIndex - startIndex).Trim();
                }
            }

            var quiz = JsonSerializer.Deserialize<AGUIWebChat.Client.Models.QuizModels.Quiz>(
                cleanedText,
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (quiz is not null)
            {
                // Successfully parsed as quiz JSON - this is a duplicate
                Logger.LogInformation("[ChatMessageItem.IsQuizJsonDuplicate] Detected quiz JSON in text (Title={Title})", quiz.Title);
                return true;
            }
        }
        catch (JsonException)
        {
            // Not valid quiz JSON - might be legitimate text
        }

        return false;
    }
}
