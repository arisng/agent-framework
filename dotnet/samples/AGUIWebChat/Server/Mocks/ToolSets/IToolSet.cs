// Copyright (c) Microsoft. All rights reserved.

using Microsoft.Agents.AI;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

namespace AGUIWebChat.Server.Mocks.ToolSets;

/// <summary>
/// Defines the interface for tool sets that simulate realistic LLM tool calling sequences.
/// </summary>
/// <remarks>
/// <para>
/// Tool sets group related tools and define their execution patterns. For example, a planning
/// tool set might emit a <c>create_plan</c> call followed by multiple <c>update_plan_step</c> calls
/// to simulate the complete planning workflow that a real LLM would perform.
/// </para>
/// <para>
/// Each tool set is triggered by specific keywords in user input and produces a sequence
/// of <see cref="AgentResponseUpdate"/> instances containing tool calls, text streaming,
/// or both.
/// </para>
/// </remarks>
public interface IToolSet
{
    /// <summary>
    /// Gets the unique name of this tool set.
    /// </summary>
    /// <value>
    /// A unique identifier for this tool set, used for logging and debugging purposes.
    /// </value>
    string Name { get; }

    /// <summary>
    /// Gets the keywords or phrases that trigger this tool set.
    /// </summary>
    /// <value>
    /// A read-only collection of keywords that, when found in user input (case-insensitive), cause this tool set to be selected.
    /// </value>
    /// <remarks>
    /// Keywords are matched case-insensitively against user input. The first matching tool set
    /// registered with the registry will be used.
    /// </remarks>
    IReadOnlyList<string> TriggerKeywords { get; }

    /// <summary>
    /// Executes the tool set sequence, yielding response updates as they are generated.
    /// </summary>
    /// <param name="context">The execution context containing response metadata and helper methods.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests.</param>
    /// <returns>
    /// An asynchronous enumerable of <see cref="AgentResponseUpdate"/> instances representing
    /// the tool calls, text streaming, or other response content generated by this tool set.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Implementations should yield updates as they become available to enable realistic
    /// streaming behavior. For multi-step sequences (like create_plan followed by update_plan_step),
    /// each step should be yielded separately with appropriate delays between them.
    /// </para>
    /// <para>
    /// The <paramref name="context"/> provides helper delegates for creating tool call updates
    /// and streaming text, ensuring consistent formatting across all tool sets.
    /// </para>
    /// </remarks>
    IAsyncEnumerable<AgentResponseUpdate> ExecuteSequenceAsync(
        MockSequenceContext context,
        CancellationToken cancellationToken = default);
}

/// <summary>
/// Provides execution context and helper methods for tool set sequence execution.
/// </summary>
/// <remarks>
/// <para>
/// This context class encapsulates the response metadata (IDs, timestamps) and provides
/// helper delegates for creating consistent response updates across all tool sets.
/// </para>
/// <para>
/// Tool sets should use the provided helper delegates rather than creating updates directly
/// to ensure consistent ID formatting and response structure.
/// </para>
/// <para>
/// The context also provides access to an <see cref="ILoggerFactory"/> for creating scoped
/// loggers within tool sets, enabling structured logging of tool execution events.
/// </para>
/// </remarks>
public sealed class MockSequenceContext
{
    /// <summary>
    /// Initializes a new instance of the <see cref="MockSequenceContext"/> class.
    /// </summary>
    /// <param name="responseId">The unique identifier for the entire response.</param>
    /// <param name="createdAt">The timestamp when the response was created.</param>
    /// <param name="userMessage">The original user message that triggered this tool set.</param>
    /// <param name="streamingDelayMs">The delay in milliseconds between streaming tokens.</param>
    /// <param name="agentName">The name of the agent generating responses.</param>
    /// <param name="loggerFactory">The logger factory for creating scoped loggers. If <see langword="null"/>, logging will be disabled.</param>
    /// <exception cref="ArgumentNullException"><paramref name="responseId"/> is <see langword="null"/>.</exception>
    public MockSequenceContext(
        string responseId,
        DateTimeOffset createdAt,
        string? userMessage,
        int streamingDelayMs,
        string? agentName = null,
        ILoggerFactory? loggerFactory = null)
    {
        ArgumentNullException.ThrowIfNull(responseId);

        this.ResponseId = responseId;
        this.CreatedAt = createdAt;
        this.UserMessage = userMessage;
        this.StreamingDelayMs = streamingDelayMs;
        this.AgentName = agentName;
        this.LoggerFactory = loggerFactory;
    }

    /// <summary>
    /// Gets the unique identifier for the entire response.
    /// </summary>
    /// <value>A unique string identifier in the format "mock_resp_{guid}".</value>
    public string ResponseId { get; }

    /// <summary>
    /// Gets the timestamp when the response was created.
    /// </summary>
    /// <value>The creation time of this response.</value>
    public DateTimeOffset CreatedAt { get; }

    /// <summary>
    /// Gets the original user message that triggered this tool set.
    /// </summary>
    /// <value>The user's input text, or <see langword="null"/> if not available.</value>
    public string? UserMessage { get; }

    /// <summary>
    /// Gets the delay in milliseconds between streaming tokens.
    /// </summary>
    /// <value>The streaming delay in milliseconds.</value>
    public int StreamingDelayMs { get; }

    /// <summary>
    /// Gets the name of the agent generating responses.
    /// </summary>
    /// <value>The agent name, or <see langword="null"/> if not set.</value>
    public string? AgentName { get; }

    /// <summary>
    /// Gets the logger factory for creating scoped loggers.
    /// </summary>
    /// <value>
    /// The <see cref="ILoggerFactory"/> instance, or <see langword="null"/> if logging is disabled.
    /// </value>
    /// <remarks>
    /// Tool sets can use this property to create loggers scoped to their specific type,
    /// enabling structured logging of tool execution events including timing, arguments,
    /// and results.
    /// </remarks>
    public ILoggerFactory? LoggerFactory { get; }

    /// <summary>
    /// Creates a logger scoped to the specified type.
    /// </summary>
    /// <typeparam name="T">The type to create the logger for.</typeparam>
    /// <returns>
    /// An <see cref="ILogger{T}"/> instance if <see cref="LoggerFactory"/> is available;
    /// otherwise, a null logger that discards all log entries.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Tool sets should use this method to obtain loggers rather than accessing
    /// <see cref="LoggerFactory"/> directly, as this method handles the case where
    /// logging is disabled (LoggerFactory is null).
    /// </para>
    /// <para>
    /// Example usage:
    /// <code>
    /// var logger = context.CreateLogger&lt;PlanToolSet&gt;();
    /// logger.LogInformation("Starting plan creation with {StepCount} steps", steps.Length);
    /// </code>
    /// </para>
    /// </remarks>
    public ILogger<T> CreateLogger<T>()
    {
        return this.LoggerFactory?.CreateLogger<T>() ?? NullLogger<T>.Instance;
    }

    /// <summary>
    /// Creates a logger with the specified category name.
    /// </summary>
    /// <param name="categoryName">The category name for the logger.</param>
    /// <returns>
    /// An <see cref="ILogger"/> instance if <see cref="LoggerFactory"/> is available;
    /// otherwise, a null logger that discards all log entries.
    /// </returns>
    /// <remarks>
    /// Use this overload when you need a logger with a custom category name rather than
    /// a type-based category.
    /// </remarks>
    public ILogger CreateLogger(string categoryName)
    {
        return this.LoggerFactory?.CreateLogger(categoryName) ?? NullLoggerFactory.Instance.CreateLogger(categoryName);
    }

    /// <summary>
    /// Generates a new unique message ID.
    /// </summary>
    /// <returns>A unique message ID in the format "mock_msg_{guid}".</returns>
    public string CreateMessageId() => "mock_msg_" + Guid.NewGuid().ToString("N");

    /// <summary>
    /// Generates a new unique tool call ID.
    /// </summary>
    /// <returns>A unique call ID in the format "mock_call_{guid}".</returns>
    public string CreateCallId() => "mock_call_" + Guid.NewGuid().ToString("N");

    /// <summary>
    /// Creates an <see cref="AgentResponseUpdate"/> containing a tool call (FunctionCallContent).
    /// </summary>
    /// <param name="toolName">The name of the tool being called.</param>
    /// <param name="arguments">The arguments to pass to the tool as a dictionary.</param>
    /// <returns>An <see cref="AgentResponseUpdate"/> containing the tool call content.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="toolName"/> is <see langword="null"/>.</exception>
    public AgentResponseUpdate CreateToolCallUpdate(string toolName, IDictionary<string, object?>? arguments = null)
    {
        ArgumentNullException.ThrowIfNull(toolName);

        string messageId = this.CreateMessageId();
        string callId = this.CreateCallId();

        FunctionCallContent functionCall = new(callId, toolName, arguments);

        return new AgentResponseUpdate(ChatRole.Assistant, [functionCall])
        {
            ResponseId = this.ResponseId,
            MessageId = messageId,
            CreatedAt = this.CreatedAt,
            AuthorName = this.AgentName,
        };
    }

    /// <summary>
    /// Creates an <see cref="AgentResponseUpdate"/> containing streamed text content.
    /// </summary>
    /// <param name="text">The text content to stream.</param>
    /// <param name="messageId">The message ID to use, or <see langword="null"/> to generate a new one.</param>
    /// <returns>An <see cref="AgentResponseUpdate"/> containing the text content.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="text"/> is <see langword="null"/>.</exception>
    public AgentResponseUpdate CreateTextUpdate(string text, string? messageId = null)
    {
        ArgumentNullException.ThrowIfNull(text);

        return new AgentResponseUpdate(ChatRole.Assistant, text)
        {
            ResponseId = this.ResponseId,
            MessageId = messageId ?? this.CreateMessageId(),
            CreatedAt = this.CreatedAt,
            AuthorName = this.AgentName,
        };
    }

    /// <summary>
    /// Streams text word-by-word with configurable delay between tokens.
    /// </summary>
    /// <param name="text">The full text to stream.</param>
    /// <param name="cancellationToken">The <see cref="CancellationToken"/> to monitor for cancellation requests.</param>
    /// <returns>An asynchronous enumerable of <see cref="AgentResponseUpdate"/> instances, one per word.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="text"/> is <see langword="null"/>.</exception>
    /// <remarks>
    /// This method splits the text by spaces and yields each word as a separate update,
    /// simulating realistic LLM token streaming behavior with the configured delay.
    /// </remarks>
    public async IAsyncEnumerable<AgentResponseUpdate> StreamTextAsync(
        string text,
        [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(text);

        string messageId = this.CreateMessageId();
        string[] words = text.Split(' ', StringSplitOptions.RemoveEmptyEntries);

        for (int i = 0; i < words.Length; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();

            // Add space before words (except the first one)
            string token = i > 0 ? " " + words[i] : words[i];

            yield return new AgentResponseUpdate(ChatRole.Assistant, token)
            {
                ResponseId = this.ResponseId,
                MessageId = messageId,
                CreatedAt = this.CreatedAt,
                AuthorName = this.AgentName,
            };

            // Delay between tokens to simulate realistic streaming
            if (this.StreamingDelayMs > 0 && i < words.Length - 1)
            {
                await Task.Delay(this.StreamingDelayMs, cancellationToken).ConfigureAwait(false);
            }
        }
    }

    /// <summary>
    /// Creates an <see cref="AgentResponseUpdate"/> containing a tool result (FunctionResultContent).
    /// </summary>
    /// <param name="callId">The call ID that this result corresponds to.</param>
    /// <param name="toolName">The name of the tool that produced this result (for documentation/logging purposes).</param>
    /// <param name="result">The result object from the tool execution.</param>
    /// <returns>An <see cref="AgentResponseUpdate"/> containing the tool result content.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="callId"/> is <see langword="null"/>.</exception>
    /// <remarks>
    /// <para>
    /// This method creates a <see cref="FunctionResultContent"/> update that simulates the result
    /// of a tool execution. The result is associated with the original tool call via the <paramref name="callId"/>.
    /// </para>
    /// <para>
    /// Tool results are essential for proper UI rendering. The client uses the result content
    /// to render appropriate UI components (e.g., plan panels, weather cards) based on media type detection.
    /// </para>
    /// </remarks>
    public AgentResponseUpdate CreateToolResultUpdate(string callId, string toolName, object result)
    {
        ArgumentNullException.ThrowIfNull(callId);

        // Note: toolName is provided for documentation purposes but FunctionResultContent
        // only requires callId and result. The toolName can be inferred from the callId.
        FunctionResultContent functionResult = new(callId, result);

        return new AgentResponseUpdate(ChatRole.Tool, [functionResult])
        {
            ResponseId = this.ResponseId,
            MessageId = this.CreateMessageId(),
            CreatedAt = this.CreatedAt,
        };
    }
}
